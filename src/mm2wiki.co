xml2js = require "./xml2js"
# sax = require "./sax"

DEBUG = false

config =
	linebreak: false

console =
	log: (args...) -> global.console.log args... if DEBUG
	error: (args...) -> global.console.error args... if DEBUG

convert = (wikifile, cb) ->
	parser = new xml2js.Parser()
	parser.parseString wikifile, (err, result) ->
		cb err, js2wiki(result)

toList = (object) ->
	if object?
		if object.length > 1 then object
		else [ object ]
	else []


js2wiki = (node, depth=0) ->
	result = ""
	nodes  = []
	start  = ""
	end    = "\n"
	attr   = {}
	final  = ""

	bold         = false
	minBoldDepth = 3
	simpleText   = ""

	minBreakDepth = 3

	# break lines for deep nodes, or override with global linebreak config
	linebreak = depth >= minBreakDepth && config.linebreak

	# define node type based on node depth
	switch depth
		when 1 then start = "=";  end = "=\n"
		when 2 then start = "==";   end = "==\n"
		when 3 then start = "* "
		when 4 then start = "** "
		when 5 then start = "*** "
		when 6 then start = "**** "

	# add prefix, ignore root node
	result = start unless node["@"]?["version"]

	# handle bold nodes
	if node["font"]?["@"]?["BOLD"] is "true"
		bold = true

	# add all icons first, before adding any text
	if node["icon"]
		if node["icon"].length? then result += "#{icon2wiki icon} " for icon in node["icon"]
		else result += "#{icon2wiki node["icon"]} "

	# add link attr as wiki link before the text
	if attr = node["@"]
		if attr.TEXT                                           #handle simple texts/links
			if bold and depth >= minBoldDepth                  #add boldness
				result += "'''"; end = "'''" + end

			if attr.LINK                                       #add link with text
				result += link2wiki(attr.LINK, attr.TEXT) + end
			else                                               #add simple text without link
				result += attr.TEXT + end
		else
			if attr.LINK                                       #add link before any richtext
				result += link2wiki( attr.LINK ) + " "
			final = end                                        #postpone closing text


	# process richcontent nodes and add resulting text
	result += rich2wiki(node["richcontent"], linebreak).trim() + final if node["richcontent"]?

	# process child/"node" nodes
	result += js2wiki n, depth+1 for n in toList node["node"]

	return result

rich2wiki = (node, linebreak=false) ->
	result = ""
	splitter = if linebreak then " <br>" else " "

	o = (testObj, start, func, end="") ->
		result += start + func(testObj) + end   if testObj? and func?
		result += testObj + (start ? "") + end  if typeof testObj is 'string' and not func?

    # <-- leading whitespace test
	# traling whitespace test -->	
	if typeof node is 'string'
		result = node
	else if typeof node is 'object' and not node.length?
		# check for properties and parse them
		console.log "found: object"

		# special case html,p: linebreak must be passed for "<br>" insertion
		# WARN: <p> may not break in other tags than <p> and <body>!
		#       the first set of <p> in the <body> will break
		#       <p> in those body-<p> will also break
		result += rich2wiki node.html.body, linebreak if node.html?
		result += rich2wiki node.p, linebreak if node.p?

		# special case links: ["#"] text must be wrapped with link syntax
		if node["@"]?["href"]?
			result += link2wiki node["@"]["href"], node["#"]
		else
			o node["#"], " "

		if node["@"]?["src"]?
			result += "see image #{ node["@"]["src"] } "
			result += "[[File:#{ node["@"]["src"] }|thumb]]"

		# other cases: call rich2wiki on subnode
		# and handle node specifics (boldness, etc.)
		o node.a,       "",	       rich2wiki
		o node.img,     "",	       rich2wiki
		o node.small,   "",        rich2wiki
		o node.span,    "",        rich2wiki
		o node.strong,  "",        rich2wiki
		o node.b,       "'''",     rich2wiki, "'''"
		o node.i,       "''",      rich2wiki, "''"
		o node.br,      " <br>"

	else if node.length > 0
		console.log "found: array(#{node.length}), linebreak=#{linebreak}"
		result += (rich2wiki e for e in node).join splitter

	else console.log "found nothing!"

	console.log node
	return result

# matches for local/file/freemind/url link detection
match_http = /^\s*[hf][t]?tp[s]?/
match_localfile = /^\s*\.\/|^\s*\.\\|^\s*[\\\/\s\w-_0-9]*\.[\.\s\w-_0-9]*/ #may start with ./ or .\, may end with .* or .*.* etc.
match_wikititle = /^\s*[\\\/\s\w-_0-9]*[\s\w-_0-9]*/ #no dots
match_mmext = /\.mm\s*$/

link2wiki = (link, text) ->
	result = ""
	if text?
		if link.match match_http
			result = "[#{link} #{text}]"
		else if link.match match_localfile
			result = "#{text} [[File:#{link}]]"
			result = "mindmap: #{result}" if link.match match_mmext
			# (related wiki site: [[#{link}]])"
		else if link.match match_wikititle
			result = "#{text} [#{link}]"
		else
			result = "#{text}: #{link}"
	else #no text
		if link.match match_http
			result = "[#{link}]"
		else if link.match match_localfile
			result = "[[File:#{link}]]"
		else if link.match match_wikititle
			result = "[#{link}]"
		else
			result = "#{link}"
	return result

icon2wiki = (icon) ->
	"" unless icon["@"]?["BUILTIN"]? # handle internal only icons or return empty string
	name = icon["@"]["BUILTIN"]
	result = ""

	# helper func to make the mapping code look nice
	o = (utftext, regex) -> result = utftext if name.match regex

	# icon name to ASCII, UNICODE mappings, make sure to use
	# the output as UNICODE and that your wiki supports it.
	# TODO: implement a non-unicode version
	o "<big><big>‚ö†</big></big>",  /warning/
	o "Œµ—ó–∑",                      /freemind/
	o "<big>‚ìò</big>",             /idea/
	o "[<u>‚Ä¶</u>]",               /folder/
	o "<big>‚Åù</big>‚ò∞",            /list/
	o "|<big>‚úé</big>|",           /edit/
	o "<big><big>‚òÜ</big></big>",  /bookmark/
	o "[<small>linux</small>]",   /penguin/
	o "<big><big>‚åö</big></big>",  /clock/
	result

# directly converts a mm file to wiki syntax and puts the result to std out
commandline = (filename) ->
	fs = require "fs"
	file = fs.readFileSync filename, "UTF-8"
	convert file, (err, result) ->
		if err then global.console.error err
		else global.console.log result
		return
	return
		

module.exports.convert = convert
module.exports.cli = commandline

# test for command line usage and call commandline with proper arguments
argv = process.argv
if argv.length > 2 and argv[2] == "mm2wiki" and argv[3]?
	commandline argv[3]





















### ASCII art
# http://utf8-characters.com/geometric-shapes/
# idea: [<u>‚Ñ¶</u>]
# table: ùÑú
# warn: ‚ö†
# musical: ùÑö
# trigram: ‚ò∞ùÑö
# tetragrams: ùçî
# digrams: ùåÖ
# ‚ñà‚ñ¨‚ñà ‚ñà ‚ñÄ‚ñà‚ñÄ
# ‚ñà!‚ñà
# <!>
# <mm>
# &lt;&#F723&gt;
###

###
# LIST OF FREEMIND BUILTIN ICONS:
# -------------------------------
# attach
# back
# bell
# bookmark
# clanbomber
# desktopnew
# flag
# forward
# gohome
# help
# idea
# kaddressbook
# knotify
# korn
# licq
# mail
# password
# pencil
# penguin
# priority-1
# priority-2
# priority-3
# priority-4
# priority-5
# priority-6
# priority-7
# stop
# warning
# wizard
# xmag
###
